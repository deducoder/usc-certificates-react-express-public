<!-- Generated by SpecStory -->

# Flujo de Información en Calificaciones (FDS) (2025-05-14 15:40:01)

_**User**_

Desde StudentsPage como la entrada, quiero que me describas el proceso que sigue la información al ingresar una calificación en @ScoresPage.tsx, este modulo envía los datos backend que se procesan en @scores.ts y @score.ts . Sé lo más detallado posible de cómo es el flujo de comunicación entre las partes.

---

_**Assistant**_



---

# Flujo de comunicación para ingresar calificaciones

## 1. Navegación desde StudentsPage a ScoresPage

En StudentsPage.tsx, el usuario accede a las calificaciones de un estudiante mediante el ícono de PinIcon:
```143:156:client/src/pages/StudentsPage.tsx
<NavLink
  to={`/administrar/alumnos/calificaciones/${params.row.id}`}
  style={{ textDecoration: "none" }}
>
  <IconButton
    color="warning"
    disabled={params.row.STUDENT_STATUS === 0}
  >
    <PinIcon></PinIcon>
  </IconButton>
</NavLink>
```

## 2. Carga inicial en ScoresPage

Cuando ScoresPage se carga:
- Obtiene el studentId de los parámetros URL mediante `useParams()`
- Ejecuta varias peticiones fetch en useEffect para obtener:
  - Información del estudiante
  - Carrera del estudiante
  - Materias de la carrera
  - Calificaciones existentes del estudiante

## 3. Ingreso de calificación

En ScoresPage, cuando el usuario ingresa una calificación y hace clic en el botón AddIcon, se activa:
```168:178:client/src/pages/ScoresPage.tsx
<IconButton
  color="primary"
  onClick={() => handleScoreSubmit(params.row)}
>
  <AddIcon></AddIcon>
</IconButton>
```

## 4. Envío de datos al servidor

La función handleScoreSubmit prepara y envía los datos:
```190:201:client/src/pages/ScoresPage.tsx
const dataToSend = {
  STUDENT_ID: studentId,
  SUBJECT_ID: score.id,
  SCORE: score.SCORE,
  SCORE_OBSERVATION: score.SCORE_OBSERVATION,
};

const response = await fetch(
  `${import.meta.env.VITE_API_URL}/api/scores`,
  {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(dataToSend),
  }
);
```

## 5. Procesamiento en el servidor (controllers/scores.ts)

El controlador postScore recibe la petición:
```43:76:server/controllers/scores.ts
export const postScore = async (req: Request, res: Response) => {
  const { STUDENT_ID, SUBJECT_ID, SCORE, SCORE_OBSERVATION } = req.body;
  try {
    // Verifica que exista el estudiante
    const existStudent = await Student.findByPk(STUDENT_ID);
    if (!existStudent) {
      return res.status(404).json({
        msg: `don't exist a student with id: ${STUDENT_ID}`,
      });
    } else {
      // Verifica que no exista ya una calificación para esta materia/estudiante
      const existScore = await Score.findOne({
        where: {
          STUDENT_ID: STUDENT_ID,
          SUBJECT_ID: SUBJECT_ID,
        },
      });
      if (existScore) {
        return res.status(400).json({
          msg: `already exist a score with user: ${STUDENT_ID} in subject: ${SUBJECT_ID}`,
        });
      } else {
        // Crea la nueva calificación
        const score = await Score.create({
          STUDENT_ID,
          SUBJECT_ID,
          SCORE,
          SCORE_OBSERVATION,
        });
        res.json(score);
      }
    }
  }
}
```

## 6. Modelo de datos (models/score.ts)

El modelo Score define la estructura de datos y validaciones:
```8:45:server/models/score.ts
const Score = db.define(
  "Score",
  {
    SCORE_ID: {
      type: DataTypes.INTEGER,
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
    },
    STUDENT_ID: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: Student,
        key: "STUDENT_ID",
      },
    },
    SUBJECT_ID: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: Subject,
        key: "SUBJECT_ID",
      },
    },
    SCORE: {
      type: DataTypes.INTEGER,
      allowNull: false,
      validate: {
        max: 10.0,
        min: 0.0,
      },
    },
    SCORE_OBSERVATION: {
      type: DataTypes.STRING,
      validate: {
        isIn: [["EX", "TS", "EQ", "ex", "ts", "eq"]],
      },
    },
```

## 7. Respuesta y actualización de UI

ScoresPage maneja la respuesta:
- Muestra un mensaje de éxito o error usando AlertMessage
- Actualiza el estado local de calificaciones para reflejar el cambio inmediatamente
- El componente DataGrid se actualiza automáticamente mostrando la nueva calificación

---

_**User**_

Puedes decirme cual el PK que define la relación entre toda la información

---

_**Assistant**_



---

El PK que define la relación entre toda la información es el `STUDENT_ID`. Este identificador funciona como el eje central que conecta todas las entidades:

1. En el modelo Score (server/models/score.ts):
   - `STUDENT_ID` es clave foránea que conecta con la tabla de estudiantes
   - La combinación de `STUDENT_ID` y `SUBJECT_ID` crea la relación entre estudiantes y materias

2. En el flujo de la aplicación:
   - Se pasa como parámetro en la URL: `/administrar/alumnos/calificaciones/${params.row.id}`
   - Se utiliza para obtener la información del estudiante
   - Se usa para buscar las carreras asociadas al estudiante
   - Permite recuperar todas las calificaciones del estudiante

3. En las consultas al backend:
   - El controlador verifica primero si existe un estudiante con ese ID
   - Luego comprueba si ya existe una calificación para ese estudiante en esa materia

Esta arquitectura permite que toda la información esté relacionada a través del `STUDENT_ID`, haciendo posible acceder a todos los datos relevantes de un estudiante desde cualquier parte de la aplicación.

---

